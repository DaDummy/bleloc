\chapter{Challenges in working with the Java Persistence API}
The Java Persistence API (JPA2) provides a framework for mapping relational database schemata to java objects. Annotations are used to create a markup of data fields and object Entities. The Entities are managed through an EntityManager. It executes basic CRUD (create, read, update, delete) functions. Data operations can be bundled inside a transaction that provides data access integrity (to a point). An EntityManager is associated with a PersistenceContext which keeps track of an object's state, caches data and queries.\paragraph{}

There are several ways persistence can be integrated into a java application. There are container managed, transaction-scoped, application-scoped and extended EntityManagers. They differ in the when and where a PersistenceContext is initiated. This has consequences as to how transactions can be scoped, their commit to rollback ratio and how lang databases have to locked. This is especially important for multi-threaded server applications, as the EntityManagers are not in themselves thread-safe. There are interactions between JPA2 and the Java Trasaction API (JTA), so a basic knowledge of both is required to make an informed decision. \paragraph{}

As JPA2 is an API, an implementation is required to be able to actually use it in the application. There are several implementations available. Hibernate is the oldest implementation, it is very mature and has a large user base. EclipseLink is also popular and more lightweight. The Spring framework also provides an integrated implementation of JPA2.  As this is the binding link between the annotated code and the application structure, this choice has to be made taking into account the other frameworks and services used in the project and the server and database it will be deployed on. \paragraph{}

Another source of problems is the fact that the JPA2 specification leaves some room for interpretation in several key elements, such as the table structure for entity relationships or the execution order of operations within the transaction to consolidate entity states. These can be the cause of many bugs if not carefully programmed around.\paragraph{}

Unit testing of persistence classes is a challenge. Unit test should cover the class methods only, not their interactions via the API. Testing with an in-memory database configuration technically constitutes an integration test. However, since large parts of the functionality in model classes is data retrieval and manipulation, simply testing the annotation format is almost useless. The source of most of the initial errors are the a fore mentioned subtleties in the interpretation of JPA2 by the implementation. Test driven development has proven extremely useful to navigate this overarching complexity.\paragraph{}
